datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// NextAuth.js tables
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@index([provider])
  @@index([expires_at])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([expires])
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  password      String?   // Mot de passe hashé pour l'authentification par email
  image         String?
  role          UserRole  @default(USER)
  accounts      Account[]
  sessions      Session[]
  missions      Mission[] // Relation avec les missions créées par l'utilisateur
  analyticsConnections   AnalyticsConnection[]
  couponRedemptions      CouponRedemption[]
  premiumAccess          PremiumAccess?
  userCredits            UserCredits?
  refundRequests         RefundRequest[]
  payments              Payment[] // Relation avec les paiements
  botRecommendations     BotRecommendation[] // Recommandations générées par les bots
  bots                  Bot[] // Bots créés par l'utilisateur
  messages              Message[] // Messages envoyés/reçus
  supportTickets        SupportTicket[] // Tickets de support créés
  assignedTickets       SupportTicket[] @relation("AssignedTickets") // Tickets assignés
  targetedCompanies     TargetedCompany[] // Entreprises ciblées
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Stripe fields
  stripeCustomerId       String?   @unique
  subscriptionId         String?   @unique // Renommé pour plus de clarté
  subscriptionStatus     String?   // active, cancelled, past_due, etc.
  subscriptionPlan       String?   // competitor_intelligence, competitor_intelligence_yearly
  subscriptionEndDate    DateTime?
  cancelAtPeriodEnd      Boolean   @default(false)
  
  @@index([role])
  @@index([email])
  @@index([createdAt])
  @@index([subscriptionStatus])
  @@index([subscriptionPlan])
  @@index([subscriptionEndDate])
  @@index([stripeCustomerId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@index([expires])
}

// Modèle pour stocker les prompts des agents
model AgentPrompt {
  id          String   @id @default(cuid())
  agentId     String   @unique // karine, hugo, jpbot, elodie, etc.
  agentName   String   // Nom affiché
  systemPrompt String  @db.Text // Prompt système principal
  rolePrompt   String  @db.Text // Prompt de rôle spécifique
  instructions String  @db.Text // Instructions détaillées
  isActive    Boolean  @default(true)
  version     Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // ID de l'utilisateur qui a créé/modifié
  
  @@index([agentId])
  @@index([isActive])
  @@index([createdAt])
  @@index([createdBy])
}

model Mission {
  id             String        @id @default(cuid())
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  source         String
  sourceEventId  String?
  objective      String
  deadline       DateTime?
  priority       String?
  context        String?
  status         String        @default("received")
  briefs         Brief[]
  deliverables   Deliverable[]
  report         Report?
  notionPageId   String?
  slackMessageTs String?
  userId         String?       // Utilisateur qui a créé la mission
  botId          String?       // Bot assigné à la mission
  user           User?         @relation(fields: [userId], references: [id])
  bot            Bot?          @relation(fields: [botId], references: [id], onDelete: SetNull)
  recommendations BotRecommendation[] // Recommandations liées à cette mission
  orchestrationPlan OrchestrationPlan? // Plan d'orchestration IA
  
  @@index([userId])
  @@index([botId])
  @@index([status])
  @@index([priority])
  @@index([source])
  @@index([createdAt])
  @@index([deadline])
  @@index([status, priority])
  @@index([userId, status])
  @@index([botId, status])
  @@index([createdAt, status])
}

model Brief {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  missionId   String
  agent       String
  contentJson Json
  status      String      @default("queued")
  mission     Mission     @relation(fields: [missionId], references: [id])
  deliverable Deliverable?
  
  @@index([missionId])
  @@index([agent])
  @@index([status])
  @@index([createdAt])
  @@index([missionId, status])
  @@index([agent, status])
}

model Deliverable {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  missionId  String
  briefId    String?  @unique
  agent      String
  output     Json
  mission    Mission  @relation(fields: [missionId], references: [id])
  brief      Brief?   @relation(fields: [briefId], references: [id])
  
  @@index([missionId])
  @@index([agent])
  @@index([createdAt])
  @@index([missionId, agent])
}

model Report {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  missionId  String   @unique
  summary    String
  detailsMd  String
  cautions   String?
  nextSteps  String?
  mission    Mission  @relation(fields: [missionId], references: [id])
  
  @@index([createdAt])
}

// Modèle pour les plans d'orchestration IA
model OrchestrationPlan {
  id                String   @id @default(cuid())
  missionId         String   @unique
  agents            String[] // IDs des agents sélectionnés
  workflow          Json     // Workflow d'exécution
  estimatedDuration Int      // Durée estimée en minutes
  confidence        Int      // Niveau de confiance (0-100)
  risks             String[] // Risques identifiés
  alternatives      Json     // Plans alternatifs
  status            String   @default("created") // created, executing, completed, failed
  executedAt        DateTime?
  completedAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relations
  mission           Mission  @relation(fields: [missionId], references: [id], onDelete: Cascade)
  
  @@index([missionId])
  @@index([status])
  @@index([createdAt])
  @@index([confidence])
  @@index([status, confidence])
}

model AnalyticsConnection {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  userId       String
  propertyId   String
  propertyName String
  websiteUrl   String?
  accessToken  String   @db.Text
  refreshToken String   @db.Text
  lastSync     DateTime?
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, propertyId])
  @@index([userId])
  @@index([propertyId])
  @@index([lastSync])
  @@index([userId, lastSync])
}

model ExecutionLog {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  missionId  String?
  briefId    String?
  stage      String
  level      String
  message    String
  meta       Json?
  
  @@index([missionId])
  @@index([briefId])
  @@index([stage])
  @@index([level])
  @@index([createdAt])
  @@index([missionId, stage])
  @@index([createdAt, level])
}

model WebhookEvent {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  source        String
  externalId    String   @unique
  payload       Json
  processedAt   DateTime?
  missionId     String?
  processingErr String?
  
  @@index([source])
  @@index([missionId])
  @@index([createdAt])
  @@index([processedAt])
  @@index([source, processedAt])
  @@index([missionId, processedAt])
}

// Système de coupons et accès premium temporaires
enum CouponType {
  PREMIUM_TRIAL    // Accès premium temporaire
  PLAN_UPGRADE     // Mise à niveau de plan
  DISCOUNT         // Réduction sur abonnement
}

enum CouponStatus {
  ACTIVE
  USED
  EXPIRED
  DISABLED
}

model Coupon {
  id          String       @id @default(cuid())
  code        String       @unique
  type        CouponType
  status      CouponStatus @default(ACTIVE)
  
  // Détails du coupon
  description String?
  planId      String?      // Plan à activer (starter, pro, enterprise)
  duration    Int?         // Durée en jours (90 pour 3 mois, 365 pour 1 an)
  discount    Int?         // Pourcentage de réduction (pour type DISCOUNT)
  
  // Limites d'utilisation
  maxUses     Int?         // Nombre max d'utilisations (null = illimité)
  currentUses Int          @default(0)
  
  // Validité
  validFrom   DateTime     @default(now())
  validUntil  DateTime?
  
  // Métadonnées
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  createdBy   String       // ID de l'admin qui a créé le coupon
  notes       String?      // Notes internes
  
  // Relations
  redemptions CouponRedemption[]
  
  @@index([type])
  @@index([status])
  @@index([planId])
  @@index([validFrom])
  @@index([validUntil])
  @@index([createdBy])
  @@index([status, validUntil])
  @@index([type, status])
}

model CouponRedemption {
  id         String   @id @default(cuid())
  couponId   String
  userId     String
  redeemedAt DateTime @default(now())
  
  // Détails de l'activation
  planActivated String? // Plan activé
  expiresAt     DateTime? // Quand l'accès premium expire
  
  // Relations
  coupon Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([couponId, userId]) // Un utilisateur ne peut utiliser qu'une fois le même coupon
  @@index([couponId])
  @@index([userId])
  @@index([redeemedAt])
  @@index([expiresAt])
  @@index([planActivated])
}

// Extension du modèle User pour les accès premium temporaires
model PremiumAccess {
  id          String   @id @default(cuid())
  userId      String   @unique
  planId      String   // starter, pro, enterprise
  startDate   DateTime @default(now())
  endDate     DateTime
  isActive    Boolean  @default(true)
  
  // Source de l'accès premium
  source      String   // 'coupon', 'admin_grant', 'stripe'
  sourceId    String?  // ID du coupon ou autre référence
  
  // Métadonnées
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // ID de l'admin qui a accordé l'accès
  notes       String?
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([planId])
  @@index([isActive])
  @@index([startDate])
  @@index([endDate])
  @@index([source])
  @@index([createdBy])
  @@index([isActive, endDate])
  @@index([planId, isActive])
}

// Système de crédits et remboursements
enum RefundStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum RefundReason {
  QUALITY_ISSUE
  TECHNICAL_PROBLEM
  NOT_SATISFIED
  DUPLICATE_CHARGE
  OTHER
}

model UserCredits {
  id          String   @id @default(cuid())
  userId      String   @unique
  planId      String   // free, pro, enterprise
  creditsUsed Int      @default(0)
  creditsLimit Int     // Limite mensuelle selon le plan
  resetDate   DateTime // Date de reset des crédits (jour de l'abonnement)
  
  // Métadonnées
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  refundRequests RefundRequest[]
  
  @@index([planId])
  @@index([resetDate])
  @@index([creditsUsed])
  @@index([planId, resetDate])
}

model RefundRequest {
  id          String        @id @default(cuid())
  userId      String
  missionId   String?       // Mission concernée (optionnel)
  amount      Int           // Nombre de crédits à rembourser
  reason      RefundReason
  description String        @db.Text // Explication détaillée
  status      RefundStatus  @default(PENDING)
  
  // Traitement
  reviewedBy  String?       // ID de l'admin qui a traité
  reviewedAt  DateTime?
  adminNotes  String?       @db.Text // Notes internes
  
  // Métadonnées
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userCredits UserCredits @relation(fields: [userCreditsId], references: [id], onDelete: Cascade)
  userCreditsId String
  
  @@index([userId])
  @@index([missionId])
  @@index([status])
  @@index([reason])
  @@index([reviewedBy])
  @@index([createdAt])
  @@index([reviewedAt])
  @@index([status, createdAt])
  @@index([userId, status])
}

// Modèle pour les paiements Stripe
model Payment {
  id                    String   @id @default(cuid())
  stripeInvoiceId       String   @unique
  stripeCustomerId      String
  stripeSubscriptionId  String?
  amount                Int      // Montant en centimes
  currency              String   @default("usd")
  status                String   // succeeded, failed, pending
  paymentDate           DateTime @default(now())
  refunded              Boolean  @default(false)
  refundAmount          Int?     // Montant remboursé en centimes
  refundDate            DateTime?
  metadata              Json?    // Données supplémentaires
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  user                  User?    @relation(fields: [stripeCustomerId], references: [stripeCustomerId])
  
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([status])
  @@index([paymentDate])
  @@index([refunded])
  @@index([currency])
  @@index([amount])
  @@index([status, paymentDate])
  @@index([stripeCustomerId, status])
  @@index([refunded, refundDate])
}

// Modèle pour les bots IA
model Bot {
  id          String   @id @default(cuid())
  name        String
  type        String   // karine, hugo, jpbot, elodie, etc.
  description String?  @db.Text
  isActive    Boolean  @default(true)
  capabilities String[] // Fonctionnalités du bot
  settings    Json?    // Configuration spécifique au bot
  
  // Relations
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  missions    Mission[] // Missions assignées à ce bot
  recommendations BotRecommendation[] // Recommandations générées par ce bot
  messages    Message[] // Messages générés par ce bot
  
  // Métadonnées
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
  @@index([type])
  @@index([isActive])
  @@index([createdAt])
  @@index([type, isActive])
  @@index([userId, isActive])
}

// Modèle pour les recommandations générées par les bots
model BotRecommendation {
  id                  String   @id @default(cuid())
  type                String   // performance, security, ux, business, technical
  priority            String   // low, medium, high, critical
  title               String
  description         String   @db.Text
  impact              String   @db.Text
  effort              String   // low, medium, high
  estimatedTime       String
  category            String
  tags                String[] // Tags pour catégoriser
  status              String   @default("pending") // pending, approved, rejected, implemented
  implementationNotes String?  @db.Text
  
  // Relations
  userId              String
  botId               String?  // Bot qui a généré la recommandation
  missionId           String?  // Mission concernée (optionnel)
  
  // Métadonnées
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  // Relations
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  bot                 Bot?     @relation(fields: [botId], references: [id], onDelete: SetNull)
  mission             Mission? @relation(fields: [missionId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([botId])
  @@index([missionId])
  @@index([type])
  @@index([priority])
  @@index([status])
  @@index([category])
  @@index([createdAt])
  @@index([userId, status])
  @@index([botId, status])
  @@index([type, priority])
  @@index([status, priority])
  @@index([userId, type])
  @@index([botId, type])
  @@index([createdAt, status])
  @@index([userId, createdAt])
}

// Système de messagerie Beriox
enum MessageType {
  INBOUND    // Email reçu
  OUTBOUND   // Email envoyé
  INTERNAL   // Message interne
  SUPPORT    // Ticket de support
}

enum MessageStatus {
  DRAFT
  SENT
  DELIVERED
  READ
  FAILED
  PENDING
}

enum MessagePriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_FOR_USER
  RESOLVED
  CLOSED
}

enum TicketCategory {
  TECHNICAL
  BILLING
  FEATURE_REQUEST
  BUG_REPORT
  GENERAL
  FEEDBACK
}

model Message {
  id              String        @id @default(cuid())
  type            MessageType
  status          MessageStatus @default(PENDING)
  priority        MessagePriority @default(NORMAL)
  
  // Contenu
  subject         String
  body            String        @db.Text
  bodyHtml        String?       @db.Text
  fromEmail       String
  fromName        String?
  toEmail         String
  toName          String?
  ccEmails        String[]      // Emails en copie
  bccEmails       String[]      // Emails en copie cachée
  
  // Métadonnées
  messageId       String?       @unique // ID unique du message
  threadId        String?       // ID du fil de conversation
  replyToId       String?       // ID du message auquel on répond
  templateId      String?       // ID du template utilisé
  
  // Headers et métadonnées
  headers         Json?         // Headers email
  attachments     Json?         // Informations sur les pièces jointes
  metadata        Json?         // Métadonnées supplémentaires
  
  // Relations
  userId          String?       // Utilisateur qui a envoyé/reçu
  ticketId        String?       // Ticket associé
  botId           String?       // Bot qui a généré le message
  
  // Métadonnées
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  sentAt          DateTime?     // Quand le message a été envoyé
  deliveredAt     DateTime?     // Quand le message a été livré
  readAt          DateTime?     // Quand le message a été lu
  
  // Relations
  user            User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  ticket          SupportTicket? @relation(fields: [ticketId], references: [id], onDelete: SetNull)
  bot             Bot?          @relation(fields: [botId], references: [id], onDelete: SetNull)
  replies         Message[]     @relation("MessageReplies")
  parentMessage   Message?      @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([priority])
  @@index([threadId])
  @@index([createdAt])
  @@index([sentAt])
  @@index([ticketId])
  @@index([botId])
  @@index([fromEmail])
  @@index([toEmail])
  @@index([userId, type])
  @@index([status, createdAt])
  @@index([threadId, createdAt])
  @@index([ticketId, createdAt])
}

model EmailTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?
  subject     String
  body        String   @db.Text
  bodyHtml    String?  @db.Text
  
  // Variables disponibles
  variables   String[] // Liste des variables disponibles
  
  // Catégorisation
  category    String   // welcome, support, notification, etc.
  isActive    Boolean  @default(true)
  
  // Métadonnées
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // ID de l'utilisateur qui a créé
  
  @@index([category])
  @@index([isActive])
  @@index([createdBy])
}

model SupportTicket {
  id          String         @id @default(cuid())
  ticketNumber String        @unique // Numéro de ticket unique
  status      TicketStatus   @default(OPEN)
  priority    MessagePriority @default(NORMAL)
  category    TicketCategory
  
  // Contenu
  subject     String
  description String         @db.Text
  
  // Assignation
  assignedTo  String?        // ID de l'utilisateur assigné
  assignedAt  DateTime?
  
  // Relations
  userId      String         // Utilisateur qui a créé le ticket
  messages    Message[]      // Messages associés au ticket
  
  // Métadonnées
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  resolvedAt  DateTime?
  closedAt    DateTime?
  
  // Relations
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignee    User?          @relation("AssignedTickets", fields: [assignedTo], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([status])
  @@index([priority])
  @@index([category])
  @@index([assignedTo])
  @@index([createdAt])
  @@index([resolvedAt])
  @@index([status, priority])
  @@index([userId, status])
  @@index([assignedTo, status])
}

model MessageThread {
  id          String   @id @default(cuid())
  threadId    String   @unique // ID unique du fil
  subject     String
  lastMessageAt DateTime @default(now())
  
  // Participants
  participants String[] // Emails des participants
  
  // Métadonnées
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([lastMessageAt])
  @@index([participants])
}

// Modèle pour les entreprises ciblées
model TargetedCompany {
  id          String   @id @default(cuid())
  name        String
  address     String
  phone       String?
  website     String?
  email       String?
  placeId     String   @unique
  location    Json     // { lat: number, lng: number }
  
  // Métadonnées
  hasWebsite  Boolean  @default(false)
  hasEmail    Boolean  @default(false)
  hasPhone    Boolean  @default(false)
  
  // Campagne et statut
  campaignName String  @default("Default Campaign")
  notes       String?
  status      String   @default("pending") // pending, contacted, converted, rejected
  
  // Relations
  addedBy     String
  user        User     @relation(fields: [addedBy], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Index
  @@index([addedBy])
  @@index([status])
  @@index([campaignName])
  @@index([hasWebsite])
  @@index([hasEmail])
  @@index([hasPhone])
  @@index([createdAt])
  @@index([addedBy, status])
  @@index([campaignName, status])
  @@index([hasWebsite, status])
}


